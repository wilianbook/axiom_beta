// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AXIOMDAEMON_H_
#define FLATBUFFERS_GENERATED_AXIOMDAEMON_H_

#include "flatbuffers/flatbuffers.h"

struct ImageSensorSetting;

struct SPISetting;

struct SettingList;

enum class Mode : int8_t {
  Read = 0,
  Write = 1,
  MIN = Read,
  MAX = Write
};

inline const char **EnumNamesMode() {
  static const char *names[] = {
    "Read",
    "Write",
    nullptr
  };
  return names;
}

inline const char *EnumNameMode(Mode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMode()[index];
}

enum class ConnectionType : int8_t {
  Memory = 0,
  I2C = 1,
  UART = 2,
  SPI = 3,
  ImageSensor = 4,
  MIN = Memory,
  MAX = ImageSensor
};

inline const char **EnumNamesConnectionType() {
  static const char *names[] = {
    "Memory",
    "I2C",
    "UART",
    "SPI",
    "ImageSensor",
    nullptr
  };
  return names;
}

inline const char *EnumNameConnectionType(ConnectionType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesConnectionType()[index];
}

enum class ImageSensorSettings : int8_t {
  Gain = 0,
  ADCRange = 1,
  WhiteBalance = 2,
  MIN = Gain,
  MAX = WhiteBalance
};

inline const char **EnumNamesImageSensorSettings() {
  static const char *names[] = {
    "Gain",
    "ADCRange",
    "WhiteBalance",
    nullptr
  };
  return names;
}

inline const char *EnumNameImageSensorSettings(ImageSensorSettings e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesImageSensorSettings()[index];
}

enum class Setting : uint8_t {
  NONE = 0,
  ImageSensorSetting = 1,
  SPISetting = 2,
  MIN = NONE,
  MAX = SPISetting
};

inline const char **EnumNamesSetting() {
  static const char *names[] = {
    "NONE",
    "ImageSensorSetting",
    "SPISetting",
    nullptr
  };
  return names;
}

inline const char *EnumNameSetting(Setting e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSetting()[index];
}

template<typename T> struct SettingTraits {
  static const Setting enum_value = Setting::NONE;
};

template<> struct SettingTraits<ImageSensorSetting> {
  static const Setting enum_value = Setting::ImageSensorSetting;
};

template<> struct SettingTraits<SPISetting> {
  static const Setting enum_value = Setting::SPISetting;
};

bool VerifySetting(flatbuffers::Verifier &verifier, const void *obj, Setting type);
bool VerifySettingVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct ImageSensorSetting FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MODE = 4,
    VT_SETTING = 6,
    VT_PARAMETER1 = 8,
    VT_PARAMETER2 = 10
  };
  Mode mode() const {
    return static_cast<Mode>(GetField<int8_t>(VT_MODE, 0));
  }
  ImageSensorSettings setting() const {
    return static_cast<ImageSensorSettings>(GetField<int8_t>(VT_SETTING, 0));
  }
  uint16_t parameter1() const {
    return GetField<uint16_t>(VT_PARAMETER1, 0);
  }
  uint16_t parameter2() const {
    return GetField<uint16_t>(VT_PARAMETER2, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           VerifyField<int8_t>(verifier, VT_SETTING) &&
           VerifyField<uint16_t>(verifier, VT_PARAMETER1) &&
           VerifyField<uint16_t>(verifier, VT_PARAMETER2) &&
           verifier.EndTable();
  }
};

struct ImageSensorSettingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(Mode mode) {
    fbb_.AddElement<int8_t>(ImageSensorSetting::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_setting(ImageSensorSettings setting) {
    fbb_.AddElement<int8_t>(ImageSensorSetting::VT_SETTING, static_cast<int8_t>(setting), 0);
  }
  void add_parameter1(uint16_t parameter1) {
    fbb_.AddElement<uint16_t>(ImageSensorSetting::VT_PARAMETER1, parameter1, 0);
  }
  void add_parameter2(uint16_t parameter2) {
    fbb_.AddElement<uint16_t>(ImageSensorSetting::VT_PARAMETER2, parameter2, 0);
  }
  ImageSensorSettingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ImageSensorSettingBuilder &operator=(const ImageSensorSettingBuilder &);
  flatbuffers::Offset<ImageSensorSetting> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<ImageSensorSetting>(end);
    return o;
  }
};

inline flatbuffers::Offset<ImageSensorSetting> CreateImageSensorSetting(
    flatbuffers::FlatBufferBuilder &_fbb,
    Mode mode = Mode::Read,
    ImageSensorSettings setting = ImageSensorSettings::Gain,
    uint16_t parameter1 = 0,
    uint16_t parameter2 = 0) {
  ImageSensorSettingBuilder builder_(_fbb);
  builder_.add_parameter2(parameter2);
  builder_.add_parameter1(parameter1);
  builder_.add_setting(setting);
  builder_.add_mode(mode);
  return builder_.Finish();
}

struct SPISetting FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MODE = 4,
    VT_DESTINATION = 6,
    VT_CONNECTIONTYPE = 8,
    VT_PAYLOAD = 10
  };
  Mode mode() const {
    return static_cast<Mode>(GetField<int8_t>(VT_MODE, 0));
  }
  const flatbuffers::String *destination() const {
    return GetPointer<const flatbuffers::String *>(VT_DESTINATION);
  }
  ConnectionType connectionType() const {
    return static_cast<ConnectionType>(GetField<int8_t>(VT_CONNECTIONTYPE, 0));
  }
  const flatbuffers::Vector<uint8_t> *payload() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DESTINATION) &&
           verifier.Verify(destination()) &&
           VerifyField<int8_t>(verifier, VT_CONNECTIONTYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PAYLOAD) &&
           verifier.Verify(payload()) &&
           verifier.EndTable();
  }
};

struct SPISettingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(Mode mode) {
    fbb_.AddElement<int8_t>(SPISetting::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_destination(flatbuffers::Offset<flatbuffers::String> destination) {
    fbb_.AddOffset(SPISetting::VT_DESTINATION, destination);
  }
  void add_connectionType(ConnectionType connectionType) {
    fbb_.AddElement<int8_t>(SPISetting::VT_CONNECTIONTYPE, static_cast<int8_t>(connectionType), 0);
  }
  void add_payload(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload) {
    fbb_.AddOffset(SPISetting::VT_PAYLOAD, payload);
  }
  SPISettingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SPISettingBuilder &operator=(const SPISettingBuilder &);
  flatbuffers::Offset<SPISetting> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<SPISetting>(end);
    return o;
  }
};

inline flatbuffers::Offset<SPISetting> CreateSPISetting(
    flatbuffers::FlatBufferBuilder &_fbb,
    Mode mode = Mode::Read,
    flatbuffers::Offset<flatbuffers::String> destination = 0,
    ConnectionType connectionType = ConnectionType::Memory,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload = 0) {
  SPISettingBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_destination(destination);
  builder_.add_connectionType(connectionType);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<SPISetting> CreateSPISettingDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Mode mode = Mode::Read,
    const char *destination = nullptr,
    ConnectionType connectionType = ConnectionType::Memory,
    const std::vector<uint8_t> *payload = nullptr) {
  return CreateSPISetting(
      _fbb,
      mode,
      destination ? _fbb.CreateString(destination) : 0,
      connectionType,
      payload ? _fbb.CreateVector<uint8_t>(*payload) : 0);
}

struct SettingList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SETTINGS_TYPE = 4,
    VT_SETTINGS = 6
  };
  const flatbuffers::Vector<uint8_t> *settings_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SETTINGS_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *settings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_SETTINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SETTINGS_TYPE) &&
           verifier.Verify(settings_type()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SETTINGS) &&
           verifier.Verify(settings()) &&
           VerifySettingVector(verifier, settings(), settings_type()) &&
           verifier.EndTable();
  }
};

struct SettingListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_settings_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> settings_type) {
    fbb_.AddOffset(SettingList::VT_SETTINGS_TYPE, settings_type);
  }
  void add_settings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> settings) {
    fbb_.AddOffset(SettingList::VT_SETTINGS, settings);
  }
  SettingListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SettingListBuilder &operator=(const SettingListBuilder &);
  flatbuffers::Offset<SettingList> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<SettingList>(end);
    return o;
  }
};

inline flatbuffers::Offset<SettingList> CreateSettingList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> settings_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> settings = 0) {
  SettingListBuilder builder_(_fbb);
  builder_.add_settings(settings);
  builder_.add_settings_type(settings_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<SettingList> CreateSettingListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *settings_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *settings = nullptr) {
  return CreateSettingList(
      _fbb,
      settings_type ? _fbb.CreateVector<uint8_t>(*settings_type) : 0,
      settings ? _fbb.CreateVector<flatbuffers::Offset<void>>(*settings) : 0);
}

inline bool VerifySetting(flatbuffers::Verifier &verifier, const void *obj, Setting type) {
  switch (type) {
    case Setting::NONE: {
      return true;
    }
    case Setting::ImageSensorSetting: {
      auto ptr = reinterpret_cast<const ImageSensorSetting *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Setting::SPISetting: {
      auto ptr = reinterpret_cast<const SPISetting *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifySettingVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySetting(
        verifier,  values->Get(i), types->GetEnum<Setting>(i))) {
      return false;
    }
  }
  return true;
}

inline const SettingList *GetSettingList(const void *buf) {
  return flatbuffers::GetRoot<SettingList>(buf);
}

inline bool VerifySettingListBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SettingList>(nullptr);
}

inline void FinishSettingListBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SettingList> root) {
  fbb.Finish(root);
}

#endif  // FLATBUFFERS_GENERATED_AXIOMDAEMON_H_
